<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>JARVIS Pro - Private AI Assistant</title>
  <style>
    :root {
      --jarvis-blue: #58a6ff;
      --jarvis-green: #3fb950;
      --jarvis-red: #ff7b72;
      --bg-dark: #0b0f17;
      --card-bg: rgba(15, 20, 30, 0.9);
      --text-light: #c9d1d9;
    }
    
    body {
      margin: 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background-color: var(--bg-dark);
      color: var(--text-light);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
      box-sizing: border-box;
      line-height: 1.6;
    }
    
    .container {
      width: 100%;
      max-width: 800px;
      background: var(--card-bg);
      padding: 25px;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(88, 166, 255, 0.2);
      margin: auto;
    }
    
    h1 {
      color: var(--jarvis-blue);
      text-shadow: 0 0 15px rgba(88, 166, 255, 0.5);
      margin-top: 0;
      font-size: 2rem;
      text-align: center;
    }
    
    .privacy-badge {
      background: rgba(63, 185, 80, 0.2);
      border: 1px solid var(--jarvis-green);
      border-radius: 20px;
      padding: 8px 15px;
      display: inline-block;
      margin: 10px 0;
      font-size: 0.8rem;
    }
    
    #response-container {
      margin: 25px 0;
      background-color: #161b22;
      padding: 20px;
      border-radius: 12px;
      min-height: 200px;
      max-height: 400px;
      overflow-y: auto;
      box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .message {
      padding: 10px 15px;
      border-radius: 8px;
      max-width: 80%;
      word-wrap: break-word;
    }
    
    .user-message {
      background: rgba(88, 166, 255, 0.15);
      border-left: 3px solid var(--jarvis-blue);
      align-self: flex-end;
    }
    
    .jarvis-message {
      background: rgba(63, 185, 80, 0.15);
      border-left: 3px solid var(--jarvis-green);
      align-self: flex-start;
    }
    
    .error-message {
      background: rgba(255, 123, 114, 0.15);
      border-left: 3px solid var(--jarvis-red);
    }
    
    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 20px;
    }
    
    button {
      background-color: var(--jarvis-green);
      color: white;
      padding: 12px 25px;
      font-size: 1.1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      min-width: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    button:hover {
      background-color: #2ea043;
      transform: translateY(-2px);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    #micButton.listening {
      animation: pulse 1.5s infinite;
      background-color: var(--jarvis-red);
    }
    
    #authButton {
      background-color: var(--jarvis-blue);
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 123, 114, 0.7); }
      70% { box-shadow: 0 0 0 12px rgba(255, 123, 114, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 123, 114, 0); }
    }
    
    .status {
      text-align: center;
      margin: 15px 0;
      font-size: 0.9rem;
      color: #8b949e;
    }
    
    .command-list {
      background: rgba(22, 27, 34, 0.7);
      padding: 15px;
      border-radius: 8px;
      margin-top: 25px;
    }
    
    .command-list h3 {
      color: var(--jarvis-blue);
      margin-top: 0;
      margin-bottom: 10px;
    }
    
    .command-list ul {
      padding-left: 20px;
      margin: 0;
      columns: 2;
    }
    
    .command-list li {
      margin-bottom: 8px;
      break-inside: avoid;
    }
    
    @media (max-width: 600px) {
      .container {
        padding: 15px;
      }
      
      .command-list ul {
        columns: 1;
      }
      
      button {
        min-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>JARVIS Pro</h1>
    <p style="text-align: center;">Your 100% private AI assistant</p>
    <div class="privacy-badge">üîí All data stored locally | No tracking | No cloud sync</div>
    
    <div id="response-container">
      <div class="message jarvis-message">JARVIS: Initializing secure systems...</div>
    </div>
    
    <div class="status" id="status">Status: Ready | Voiceprint: Not verified</div>
    
    <div class="controls">
      <button id="micButton" onclick="toggleListening()">
        <span id="micIcon">üé§</span> <span id="micText">Start Listening</span>
      </button>
      <button id="authButton" onclick="verifyIdentity()">
        üîê Verify Identity
      </button>
    </div>
    
    <div class="command-list">
      <h3>Available Commands:</h3>
      <ul>
        <li>"Open [App] in [Browser]"</li>
        <li>"Message [Contact]: [Text]"</li>
        <li>"Call last missed number"</li>
        <li>"Turn on Bluetooth, play gym playlist"</li>
        <li>"Take screenshot and send to [Contact]"</li>
        <li>"Book Uber to work, text Lisa ETA"</li>
        <li>"Turn on hotspot, brightness 50%"</li>
        <li>"Set reminder: Call Mom at 5pm"</li>
      </ul>
    </div>
  </div>

  <script>
    // 100% Private Configuration - All data stored locally
    const config = {
      userName: localStorage.getItem('jarvis-user-name') || "Sir",
      assistantName: "JARVIS Pro",
      voiceProfile: JSON.parse(localStorage.getItem('jarvis-voice-profile')) || null,
      isAuthenticated: false,
      securityLevel: localStorage.getItem('jarvis-security-level') || "standard", // standard or strict
      defaultVoice: {
        lang: 'en-IN',
        rate: 1.0,
        pitch: 0.9
      },
      contacts: JSON.parse(localStorage.getItem('jarvis-contacts')) || {
        "mom": { name: "Mom", number: "" },
        "dad": { name: "Dad", number: "" }
      },
      appDeepLinks: {
        youtube: { native: "vnd.youtube://", web: "https://youtube.com" },
        whatsapp: { native: "whatsapp://", web: "https://web.whatsapp.com" },
        spotify: { native: "spotify://", web: "https://open.spotify.com" },
        uber: { native: "uber://", web: "https://m.uber.com" }
      },
      browserOptions: {
        chrome: "googlechrome://",
        firefox: "firefox://",
        edge: "microsoft-edge://"
      }
    };

    // DOM Elements
    const responseContainer = document.getElementById('response-container');
    const statusElement = document.getElementById('status');
    const micButton = document.getElementById('micButton');
    const micIcon = document.getElementById('micIcon');
    const micText = document.getElementById('micText');
    const authButton = document.getElementById('authButton');
    
    // System State
    let recognition;
    let isListening = false;
    let isInitialized = false;
    let speechSynthesis = window.speechSynthesis;
    let maleVoice;
    let voiceProfile = null;

    // Initialize JARVIS - 100% local
    async function initializeJarvis() {
      addMessage(config.assistantName, "Initializing secure systems...");
      
      // Load voices
      await loadVoices();
      
      // Check for speech recognition support
      if (!('webkitSpeechRecognition' in window)) {
        showError("Speech recognition not supported in your browser");
        return false;
      }
      
      // Check microphone permissions
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop());
        
        // Initialize voice profile if not exists
        if (!config.voiceProfile && confirm("Would you like to create a voiceprint for enhanced security?")) {
          createVoiceProfile();
        }
        
      } catch (error) {
        showError("Microphone access denied. Please enable permissions.");
        return false;
      }
      
      isInitialized = true;
      updateStatus();
      addMessage(config.assistantName, `Secure systems online. How may I assist you today, ${config.userName}?`);
      speak(`Secure systems online. How may I assist you today, ${config.userName}?`);
      return true;
    }

    // Voiceprint authentication
    async function verifyIdentity() {
      if (config.voiceProfile) {
        addMessage("System", "Please say: 'My voice is my password' to authenticate");
        speak("Please say: My voice is my password to authenticate");
        
        // Special authentication recognition session
        const authRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        authRecognition.lang = 'en-IN';
        authRecognition.interimResults = false;
        authRecognition.maxAlternatives = 1;
        
        authRecognition.onresult = (event) => {
          const spokenPhrase = event.results[0][0].transcript.toLowerCase();
          if (spokenPhrase.includes("my voice is my password")) {
            config.isAuthenticated = true;
            updateStatus();
            addMessage("System", "Voiceprint verified. Authentication successful.");
            speak("Authentication successful");
          } else {
            addMessage("System", "Authentication failed. Voiceprint mismatch.");
            speak("Authentication failed");
          }
        };
        
        authRecognition.start();
      } else {
        addMessage("System", "No voiceprint registered. Please create one first.");
        speak("No voiceprint registered. Please create one first.");
      }
    }

    // Create voice profile
    function createVoiceProfile() {
      addMessage("System", "Creating voiceprint. Please say: 'My voice is my password' three times.");
      speak("Creating voiceprint. Please say: My voice is my password three times.");
      
      // In a real implementation, we would analyze voice characteristics here
      // For demo purposes, we'll just store a simple profile
      config.voiceProfile = {
        created: new Date().toISOString(),
        phrase: "my voice is my password"
      };
      localStorage.setItem('jarvis-voice-profile', JSON.stringify(config.voiceProfile));
      addMessage("System", "Voiceprint created successfully.");
      speak("Voiceprint created successfully.");
      updateStatus();
    }

    // Update status display
    function updateStatus() {
      let status = "Ready";
      if (config.isAuthenticated) {
        status += " | Voiceprint: Verified";
        authButton.style.backgroundColor = "#3fb950";
      } else if (config.voiceProfile) {
        status += " | Voiceprint: Registered";
        authButton.style.backgroundColor = "#58a6ff";
      } else {
        status += " | Voiceprint: Not registered";
        authButton.style.backgroundColor = "#ff7b72";
      }
      statusElement.textContent = status;
    }

    // Load available voices
    function loadVoices() {
      return new Promise((resolve) => {
        const voices = speechSynthesis.getVoices();
        if (voices.length > 0) {
          maleVoice = voices.find(v => v.name.includes('Male') || v.lang.includes('en'));
          resolve();
        } else {
          speechSynthesis.onvoiceschanged = () => {
            maleVoice = speechSynthesis.getVoices().find(v => v.name.includes('Male') || v.lang.includes('en'));
            resolve();
          };
        }
      });
    }

    // Voice synthesis
    function speak(text) {
      if (speechSynthesis.speaking) {
        speechSynthesis.cancel();
      }
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = config.defaultVoice.lang;
      utterance.rate = config.defaultVoice.rate;
      utterance.pitch = config.defaultVoice.pitch;
      
      if (maleVoice) {
        utterance.voice = maleVoice;
      }
      
      speechSynthesis.speak(utterance);
    }

    // Toggle listening state with security check
    async function toggleListening() {
      if (!isInitialized) {
        const initialized = await initializeJarvis();
        if (!initialized) return;
      }
      
      if (config.securityLevel === "strict" && !config.isAuthenticated) {
        addMessage("System", "Authentication required for strict security mode.");
        speak("Authentication required. Please verify your identity first.");
        return;
      }
      
      if (isListening) {
        stopListening();
      } else {
        startListening();
      }
    }

    // Start secure speech recognition
    function startListening() {
      try {
        if (recognition) {
          recognition.stop();
          recognition = null;
        }
        
        recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.lang = 'en-IN';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        recognition.continuous = false;
        
        recognition.onstart = () => {
          isListening = true;
          micButton.classList.add('listening');
          micIcon.textContent = 'üõë';
          micText.textContent = 'Listening...';
          statusElement.textContent = config.isAuthenticated 
            ? 'Status: Listening (Authenticated)' 
            : 'Status: Listening (Standard Mode)';
          addMessage("System", "Listening for your command...");
        };
        
        recognition.onresult = (event) => {
          const command = event.results[0][0].transcript.trim();
          if (command.length >= 3) {
            addMessage("You", command);
            processCommand(command);
          }
        };
        
        recognition.onerror = (event) => {
          if (!['no-speech', 'aborted'].includes(event.error)) {
            showError(`Error: ${event.error}`);
          }
          stopListening();
        };
        
        recognition.onend = () => {
          stopListening();
        };
        
        recognition.start();
      } catch (error) {
        showError(`Failed to start recognition: ${error}`);
        stopListening();
      }
    }

    // Stop speech recognition
    function stopListening() {
      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {}
        recognition = null;
      }
      isListening = false;
      micButton.classList.remove('listening');
      micIcon.textContent = 'üé§';
      micText.textContent = 'Start Listening';
      updateStatus();
    }

    // Enhanced NLP command processing
    function processCommand(command) {
      const lowerCommand = command.toLowerCase();
      let response = "";
      
      // Message parsing: "Message [Contact]: [Text]"
      if (/message\s+.+:.+/i.test(command) || /text\s+.+:.+/i.test(command)) {
        const match = command.match(/(?:message|text)\s+(.+?):(.+)/i);
        if (match) {
          const contact = match[1].trim().toLowerCase();
          const message = match[2].trim();
          if (config.contacts[contact]) {
            response = `Sending message to ${config.contacts[contact].name}: "${message}"`;
            // In a real app, would integrate with SMS/messaging API here
          } else {
            response = `Contact "${contact}" not found in your local contacts.`;
          }
        }
      }
      // Open app with browser specification
      else if (/open\s+.+\s+in\s+.+/i.test(command)) {
        const match = command.match(/open\s+(.+?)\s+in\s+(.+)/i);
        if (match) {
          const app = match[1].trim().toLowerCase();
          const browser = match[2].trim().toLowerCase();
          if (config.browserOptions[browser]) {
            response = `Opening ${app} in ${browser}`;
            const webUrl = config.appDeepLinks[app]?.web;
            if (webUrl) {
              window.location.href = `${config.browserOptions[browser]}${webUrl}`;
            }
          }
        }
      }
      // Multi-step commands
      else if (lowerCommand.includes('then') || lowerCommand.includes('and')) {
        const commands = command.split(/(?:then|and)/i);
        response = "Executing multi-step command:";
        commands.forEach(cmd => {
          response += `\n- ${cmd.trim()}`;
          processCommand(cmd.trim()); // Recursively process each command
        });
      }
      // Device settings
      else if (lowerCommand.includes('turn on') || lowerCommand.includes('turn off')) {
        const setting = command.match(/(turn on|turn off)\s+(.+)/i)[2];
        response = `${lowerCommand.includes('turn on') ? 'Enabling' : 'Disabling'} ${setting}`;
        // In a real app, would integrate with device settings API
      }
      // Open app commands
      else if (lowerCommand.startsWith('open ')) {
        const app = lowerCommand.replace('open ', '').trim();
        if (config.appDeepLinks[app]) {
          response = `Opening ${app}`;
          openApp(app);
        } else {
          response = `I don't know how to open ${app} yet.`;
        }
      }
      // Default fallback
      else {
        response = "I didn't understand that command, Sir.";
      }
      
      addMessage(config.assistantName, response);
      speak(response);
      stopListening();
    }

    // Secure app opening with fallback
    function openApp(appName) {
      const app = config.appDeepLinks[appName];
      if (!app) {
        showError(`No configuration found for ${appName}`);
        return;
      }

      // Try native app first
      if (app.native) {
        try {
          const iframe = document.createElement('iframe');
          iframe.style.display = 'none';
          iframe.src = app.native;
          document.body.appendChild(iframe);
          setTimeout(() => {
            document.body.removeChild(iframe);
            // Fallback to web if app didn't open
            if (!document.hidden && app.web) {
              window.location.href = app.web;
            }
          }, 500);
        } catch (e) {
          if (app.web) window.location.href = app.web;
        }
      } else if (app.web) {
        window.location.href = app.web;
      }
    }

    // UI Helpers
    function addMessage(sender, text) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message');
      
      if (sender === config.assistantName) {
        messageDiv.classList.add('jarvis-message');
        messageDiv.innerHTML = `<strong>${sender}:</strong> ${text}`;
      } else if (sender === "System") {
        messageDiv.classList.add('error-message');
        messageDiv.innerHTML = `<em>${text}</em>`;
      } else {
        messageDiv.classList.add('user-message');
        messageDiv.innerHTML = `<strong>${sender}:</strong> ${text}`;
      }
      
      responseContainer.appendChild(messageDiv);
      scrollToBottom();
    }

    function showError(message) {
      addMessage("System", message);
    }

    function scrollToBottom() {
      responseContainer.scrollTop = responseContainer.scrollHeight;
    }

    // Initialize on load
    window.addEventListener('load', () => {
      if (window.location.protocol !== 'https:' && !window.location.hostname.includes('localhost')) {
        showError("For full security, please use HTTPS or localhost");
      }
      initializeJarvis();
    });
  </script>
</body>
</html>
